### 为什么需要内存对齐

1. 有些CPU可以访问任意地址上的任意数据，而有些CPU只能在特定地址访问数据，因此不同硬件平台具有差异性，这样的代码就不具有移植性，如果在编译时，将分配的内存进行对齐，这就具有平台可以移植性了。

2. CPU 访问内存时并不是逐个字节访问，而是以字长（word size）为单位访问，例如 32位的CPU 字长是4字节，64位的是8字节。如果变量的地址没有对齐，可能需要多次访问才能完整读取到变量内容，而对齐后可能就只需要一次内存访问，因此内存对齐可以减少CPU访问内存的次数，加大CPU访问内存的吞吐量。

### 内存对齐规则

+ 成员对齐

针对一个基础类型变量，如果 `unsafe.AlignOf()` 返回的值是 m，那么该变量的地址需要 `被m整除` （如果当前地址不能整除，填充空白字节，直至可以整除）。

+ 整体对齐

针对一个结构体，如果 `unsafe.AlignOf()` 返回值是 m，需要保证该结构体整体内存占用是 `m的整数倍`，如果当前不是整数倍，需要在后面填充空白字节(为了结构体数组也能内存对齐)。

```go
type student struct {
	name string
	sexy bool
	weight float64
	age int8
}
// 占40个字节

type student struct {
	name string
	sexy bool
	age int8
  weight float64
}
// 占32个字节
```

